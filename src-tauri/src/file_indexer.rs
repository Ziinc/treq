use crate::jj;
use crate::local_db::{self, CachedWorkspaceFile};
use chrono::Utc;
use std::collections::HashSet;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Get list of git-tracked files for a workspace
/// Uses `git ls-files` to get both cached and untracked files (respecting .gitignore)
pub fn get_git_tracked_files(workspace_path: &str) -> Result<Vec<String>, String> {
    let output = Command::new("git")
        .args(["ls-files", "--cached", "--others", "--exclude-standard"])
        .current_dir(workspace_path)
        .output()
        .map_err(|e| format!("Failed to run git ls-files: {}", e))?;

    if !output.status.success() {
        return Err(format!(
            "git ls-files failed: {}",
            String::from_utf8_lossy(&output.stderr)
        ));
    }

    let files: Vec<String> = String::from_utf8_lossy(&output.stdout)
        .lines()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    Ok(files)
}

/// Get list of files from jj status (changed files only)
/// Uses `jj status` to get only files that have been modified, added, or deleted
pub fn get_jj_status_files(workspace_path: &str) -> Result<Vec<String>, String> {
    let changes = jj::jj_get_changed_files(workspace_path)
        .map_err(|e| format!("Failed to get jj status: {}", e))?;

    Ok(changes.into_iter().map(|c| c.path).collect())
}

/// Get file modification time as unix timestamp
fn get_file_mtime(path: &Path) -> Option<i64> {
    std::fs::metadata(path)
        .ok()
        .and_then(|metadata| metadata.modified().ok())
        .and_then(|mtime| mtime.duration_since(std::time::UNIX_EPOCH).ok())
        .map(|duration| duration.as_secs() as i64)
}

/// Build a hierarchical file tree from a flat list of file paths
/// Creates directory entries with parent_path relationships for efficient querying
fn build_file_tree(
    workspace_path: &str,
    files: Vec<String>,
) -> Result<Vec<CachedWorkspaceFile>, String> {
    let workspace_path_buf = Path::new(workspace_path);
    let mut cached_files = Vec::new();
    let mut directories_seen = HashSet::new();
    let cached_at = Utc::now().to_rfc3339();

    // First pass: create entries for all files
    for file_path in files {
        let full_path = workspace_path_buf.join(&file_path);
        let full_path_str = full_path
            .to_str()
            .ok_or_else(|| format!("Invalid file path: {:?}", full_path))?
            .to_string();

        // Determine parent path
        let parent_path = if let Some(parent) = full_path.parent() {
            if parent == workspace_path_buf {
                // Root level file
                Some(workspace_path.to_string())
            } else {
                parent.to_str().map(|s| s.to_string())
            }
        } else {
            Some(workspace_path.to_string())
        };

        cached_files.push(CachedWorkspaceFile {
            id: 0, // Will be auto-generated by database
            workspace_id: None, // Will be set by caller
            file_path: full_path_str.clone(),
            relative_path: file_path.clone(),
            is_directory: false,
            parent_path,
            cached_at: cached_at.clone(),
            mtime: get_file_mtime(&full_path),
        });

        // Collect all directory components
        let path = Path::new(&file_path);
        let mut current = PathBuf::new();
        for component in path.components() {
            if let Some(comp_str) = component.as_os_str().to_str() {
                current.push(comp_str);
                if current != path {
                    // This is a directory component
                    directories_seen.insert(current.to_string_lossy().to_string());
                }
            }
        }
    }

    // Second pass: create directory entries
    for dir_rel_path in directories_seen {
        let full_dir_path = workspace_path_buf.join(&dir_rel_path);
        let full_dir_path_str = full_dir_path
            .to_str()
            .ok_or_else(|| format!("Invalid directory path: {:?}", full_dir_path))?
            .to_string();

        let parent_path = if let Some(parent) = full_dir_path.parent() {
            if parent == workspace_path_buf {
                Some(workspace_path.to_string())
            } else {
                parent.to_str().map(|s| s.to_string())
            }
        } else {
            Some(workspace_path.to_string())
        };

        cached_files.push(CachedWorkspaceFile {
            id: 0,
            workspace_id: None,
            file_path: full_dir_path_str,
            relative_path: dir_rel_path,
            is_directory: true,
            parent_path,
            cached_at: cached_at.clone(),
            mtime: get_file_mtime(&full_dir_path),
        });
    }

    Ok(cached_files)
}

/// Index workspace files into database
/// Gets files from jj status (changed files only) and builds a hierarchical cache
pub fn index_workspace_files(
    repo_path: &str,
    workspace_id: Option<i64>,
    workspace_path: &str,
) -> Result<(), String> {
    // Get only changed files from jj status
    let files = get_jj_status_files(workspace_path)?;

    // Build file tree with parent relationships
    let mut cached_files = build_file_tree(workspace_path, files)?;

    // Set workspace_id for all entries
    for file in &mut cached_files {
        file.workspace_id = workspace_id;
    }

    // Sync to database
    local_db::sync_workspace_files(repo_path, workspace_id, cached_files)?;

    Ok(())
}

/// Incrementally update specific files in the index
/// Only updates the files that have actually changed, instead of full replacement
pub fn index_changed_files(
    repo_path: &str,
    workspace_id: Option<i64>,
    workspace_path: &str,
    changed_paths: Vec<String>,
) -> Result<(), String> {
    if changed_paths.is_empty() {
        return Ok(());
    }

    let workspace_path_buf = Path::new(workspace_path);
    let mut files_to_delete = Vec::new();
    let mut directories_seen = HashSet::new();

    // Process each changed file
    for file_path in &changed_paths {
        let full_path = workspace_path_buf.join(file_path);

        if full_path.exists() {
            // File exists - upsert it
            let full_path_str = full_path
                .to_str()
                .ok_or_else(|| format!("Invalid file path: {:?}", full_path))?
                .to_string();

            let parent_path = if let Some(parent) = full_path.parent() {
                if parent == workspace_path_buf {
                    Some(workspace_path)
                } else {
                    parent.to_str()
                }
            } else {
                Some(workspace_path)
            };

            let is_directory = full_path.is_dir();
            let mtime = if is_directory {
                get_file_mtime(&full_path)
            } else {
                get_file_mtime(&full_path)
            };

            local_db::upsert_workspace_file(
                repo_path,
                workspace_id,
                &full_path_str,
                file_path,
                is_directory,
                parent_path,
                mtime,
            )?;

            // Collect parent directories
            let path = Path::new(file_path);
            let mut current = PathBuf::new();
            for component in path.components() {
                if let Some(comp_str) = component.as_os_str().to_str() {
                    current.push(comp_str);
                    if current != path {
                        directories_seen.insert(current.to_string_lossy().to_string());
                    }
                }
            }
        } else {
            // File was deleted - mark for removal
            let full_path_str = full_path
                .to_str()
                .ok_or_else(|| format!("Invalid file path: {:?}", full_path))?
                .to_string();
            files_to_delete.push(full_path_str);
        }
    }

    // Upsert parent directories
    for dir_rel_path in directories_seen {
        let full_dir_path = workspace_path_buf.join(&dir_rel_path);
        let full_dir_path_str = full_dir_path
            .to_str()
            .ok_or_else(|| format!("Invalid directory path: {:?}", full_dir_path))?
            .to_string();

        let parent_path = if let Some(parent) = full_dir_path.parent() {
            if parent == workspace_path_buf {
                Some(workspace_path)
            } else {
                parent.to_str()
            }
        } else {
            Some(workspace_path)
        };

        local_db::upsert_workspace_file(
            repo_path,
            workspace_id,
            &full_dir_path_str,
            &dir_rel_path,
            true,
            parent_path,
            get_file_mtime(&full_dir_path),
        )?;
    }

    // Delete files that no longer exist
    if !files_to_delete.is_empty() {
        local_db::delete_workspace_files(repo_path, workspace_id, files_to_delete)?;
    }

    Ok(())
}
